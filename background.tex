\section{Background}\label{sec:background}

\subsection{Concurrency Bug}

% Sequential bug -- only input. Concurrency bug -- both input and 
In multi-threaded program, concurrency bugs (unsynchronized memory access) is common and caused great loss in real world\cite{nasdaq, therac}.  
%Non-deadlock concurrency bugs includes 
%includes data races\cite{datacollider:osdi10, savage:eraser, yu:racetrack:sosp}, 
%atomicity violations\cite{}, order violations\cite{} and others which has been well studied 
%by extant studies\cite{lu:concurrency-bugs,conmem:asplos10}. 
Data race is a significant leading factor of concurrency bug and occurred when two threads 
access the same memory piece concurrently and at least one access is write\cite{datacollider:osdi10,savage:eraser, yu:racetrack:sosp}. 
Data race may cause order vilotion, atomicity violation and other concurrency bugs.
Data race detectors has been mature in industry\cite{tsan,valgrind:pldi} and 
readily detect most data races occurred.
However, a previous study \cite{lu:concurrency-bugs} shows that 
data races reported by data race detectors do not necessarily cause a concurrency bug. 
Many data races are benign race and cause no factors, \eg while-flags.
Also, our observation shows there are benign schedules in race reports.
For instance,
developers use semaphore-like adhoc synchronizations,
where one thread is busy waiting on a shared variable until
another thread sets this variable to be ``true''. This type of adhoc
synchronizations couldnâ€™t be recognized by \tsan or \ski
and caused many false positives.
In our framework \xxx, we firstly reduce these benign race reports and then do further concurrency attack detection.

 
\subsection{Concurrency Attack}

Extant studies \cite{con:hotpar12, acidrain:sigmod17} show rise of concurrency 
attacks. We conclude two main features for concurrency attacks comparing to concurrency bugs. 
First, concurrency attacks make much more severe threats:
concurrency attacks can corrupt critical memory and cause four
types of severe security consequences, including privilege escalations\cite{uselib-bug-12791, mysql-bug-24988},
malicious code injections \cite{msiexploit},  
bypassing security authentications\cite{cve-2010-0923, cve-2008-0034, cve-2010-1754}
, and breaking database integrity\cite{acidrain:sigmod17}. 

Second, concurrency bugs and attacks can often be easily
triggered by crafted program inputs, and consequences may 
become much more severe when attacks involves extra inputs.  
Existing concurrency bug detection tools are not designed to indicate 
whether a concurrency bug is vulnerable and exploitable.


\subsection{Bug-to-Attack Propagation}

In traditional sequential context, attacks are triggered by certain inputs. 
Program path and execution order is often 
determined once input is given. 
In concurrency context, attacks are triggered by both input and interleaving\cite{con-bugs,con:hotpar12}. 
%The program execution and path is
There has been tools to analyze sequential attacks. 
They often trace the input and do program path analysis. 
For instance, mayhem\cite{mayhem:cmu} is the first to propose detecting 
sequential attacks and automatically generating exploit scripts, which has made great progress. 
It employees a hybrid 
approach of concrete and symbolic execution and achieves automatically 
exploiting vulnerabilities. 

However, conventional sequential approach is not suitable in concurrency context. 
We conclude in two points. First,  


Con-seq intra-procedural propagation .. 




