\section{Evaluation}
\label{sec:evaluation}

We evaluated \xxx on \nreproducedProgs widely used C/C++ programs, including 
three server applications (\apache~\cite{apache} web server, 
\mysql~\cite{mysql} database server, and SSDB~\cite{SSDB} 
key-value store server), one library (\libsafe~\cite{libsafe}), the Linux 
kernel, and one web browser (\chrome). We used the programs' common performance 
benchmarks as workloads. Our evaluation was done on a 3.60 GHz 8-core 
Intel Xeon machine with 32 GB memory and 1TB SSD running Linux 3.19.0-49. 
% In addition to the \nreproducedProgs open source programs we were 
% able to run in our study (see Table~\ref{tab:study}), the two \memcached and 
% \mongoose servers are added to evaluate \xxx. 

% For inputs, we leverage existing concurrency bug triggering
% inputs and the default test suites of each application.

We focused our evaluation on four key questions:
\begin{tightenum}

\item Is \xxx easy to use (\S\ref{sec:ease-of-use})?

% \item How much can \xxx reduce the race reports that are not 
% vulnerable (\S\ref{sec:reduction})?

\item How many false reports from concurrency error 
detection tools can \xxx reduce (\S\ref{sec:reduce})?

\item Can \xxx detect known concurrency attacks in the real-world
(\S\ref{sec:known-attacks})?

\item Can \xxx detect previously unknown concurrency attacks in the real-world
(\S\ref{sec:unknown-attacks})?

%\item How fast does \xxx's analysis tool run on real-world programs  
%(\S\ref{sec:perf})?

%\item How many false negatives did \xxx introduce for 
%concurrency error detection tools (\S\ref{sec:false-negative})?

\end{tightenum}

\begin{table}[ht!]
\footnotesize
\centering
\begin{tabular}{l|r|r|r|r|r|r|r}
{\bf Name} & {\bf LoC} & {\bf \# atks} & 
    {\bf \# atks found} & 
    {\bf \# \xxx's reports} \\
\hline
\apache                 &    290K  &   3 &   3 & 10 \\
\chrome                 &    3.4M  &   1 &   1 & 115 \\
%\freebsd                &    TBD   &   2 &   X &  X    & X  & X   \\
\libsafe                &    3.4K  &   1 &   1 & 3  \\
%\libvirt                &    680K  &   1 &   0 & 0  \\
%\linux                  &    2.8M  &   2 &   2 & 34  \\
\linux                 &    2.8M  &   2 &   2 & 34  \\
% \memcached              &    14.7K &   0 &   0 & 14 \\
% \mongoose               &    7.6K  &   0 &   0 & 0  \\
\mysql                  &    1.5M  &   2 &   2 & 16 \\
\ssdb                   &    67K   &   1 &   1 & 2  \\
\hline\\[-2.3ex]
Total                   &   5.36M  &  11 &  10 & 180 \\
\end{tabular}
\vspace{-.1in}
\caption{{\em \xxx concurrency attack detection results.} \rm {We selected 
\nreproduced concurrency attacks because we were able to trigger their bugs on 
our machines. \xxx detected all \nbackendDetected 
evaluated concurrency attacks.}} 
\label{tab:eval}
\vspace{-.2in}
\end{table}

%\begin{table}[t]
%\footnotesize
%\centering
%\vspace{-.05in}
%\begin{tabular}{p{1cm}p{1cm}p{0.6cm}p{0.6cm}p{0.6cm}p{0.6cm}p{0.6cm}p{0.6cm}}
    %{\bf Name} & {\bf Race Reports} & {\bf {Dup}} &
    %{\bf Busy Loop} & {\bf Self-sync} & {\bf Bitop} & {\bf Remain}\\
%\hline\\[-1.3ex]
%\apache                &  783   & 527   & 31  & 0   &  0 & 225 \\
%\chrome                &  1715  & 1524  & 0   & 1   &  0 & 190 \\
%\libsafe               &  3     & 0     & 0   & 0   &  0 & 3  \\
%\libvirt               &  0     & 0     & 0   & 0   &  0 & 0  \\
%\linux                 &  24641 & 22915 & 8   & 0   &  0 & 1718 \\
%% \memcached             &  5102 & 33  & 0   & 0   &  0 & 33 \\
%% \mongoose              &  90   & 57  & 57  & 0   &  0 & 0  \\
%\mysql                 &  530   & 132   & 49  & 87  &  3 & 259 \\
%\ssdb                  &  12    & 1     & 0   & 0   &  0 & 11  \\
%%\freebsd               &  X    &  X  & X   &  X & X  \\
%\hline\\[-2.3ex]                                     
%Total                  & 27684  & 25099 & 88  & 88  &  3 & 2406\\
%\end{tabular}
%\vspace{-.05in}
%\caption{{\em \xxx's race filter results.}} 
%\label{tab:racefilter}
%\end{table}

%\begin{table*}[t]
%\footnotesize
%\centering
%\begin{tabular}{l|l|l|l|l|l|l|l|l|r}
%\hline
%\multirow{2}{*}{\bf Name} & \multicolumn{2}{ |c| } {\bf Race Reports} 
    %& \multicolumn{2}{ |c| }{\bf {Duplicates \& W.W.}}
    %& \multirow{2}{*}{\bf Adhoc Sync.} & \multirow{2}{*}{\bf Customized Sync.}
    %& \multirow{2}{*}{\bf Race Verifier} & \multirow{2}{*}{\bf Remain} & \multirow{2}{*}{\bf Avg. Cost} \\ \cmidrule(r){2-3} \cmidrule(r){4-5}
                       %&  {\bf W/O} & {\bf W} & {\bf W/O} & {\bf W} & & & \\ \hline
%\apache                &  715  & 1516   & 654   & 1432   & 86  & 0   & 74  & 10   & 1.5m \\
%\chrome                &  1715 & 1715   & 1524  & 1524   & 0   & 1   & 64  & 126  & 190m \\
%\libsafe               &  3    & 3      & 0     & 0      & 0   & 0   & 0   & 3    & 3s\\
%%\libvirt               &  0     & 0     & 0   & 0   & 0  \\
%\linux                 &  24641 & 24641 & 22915 & 22915  & 8   & 0   & N/A & 1718 & 42.5m \\
%\memcached             &  5376  & 5376  & 5347  & 5347   & 0   & 0   & 25  & 4 & 1.2m \\
%%% \mongoose              &  90   & 57  & 57  & 0   &  0 & 0  \\
%\mysql                 &  1123  & 870   & 1016  & 768    & 136 & 87  & 84  & 18 & 5.1m\\
%\ssdb                  &  12    & 12    & 1     & 1      & 0   & 0   & 9   & 2  & 1.3m \\ \hline
%Total                  & 31870  & 32418 & 29933 & 31987 & 230  & 88  & 256 & 1881 & N/A \\
%\hline
%\end{tabular}
%\caption{{\em \xxx's reduction results.}}
%\label{tab:racefilter}
%\vspace{-.1in}
%\end{table*}



\subsection{Ease of Use}\label{sec:ease-of-use}
Table~\ref{tab:eval} shows a summary of our concurrency attack detection 
results. Overall, \xxx was able to automatically run the evaluated applications 
and generate verified concurrency attacks with moderate developer intervention 
(inspect vulnerable inputs from input hints).
% Comparing with traditional adhoc 
% way of concurrency attacks detection, \xxx largely reduced the unrelated 
% schedules, race reports and program inputs. 


%Our static analysis part requires the pre-generated
%LLVM bitcode of the application. We use whole-program-llvm~\cite{wllvm} to 
%automatically generate them
%except for Linux kernel.
%Besides these preparations, \xxx is able to automatically generate potential concurrency attack
%reports with developers' test suites or popular benchmark programs.

It's critical to report the connection between a concurrency bug and its vulnerability.
\xxx provides an expressive and helpful reports to (1) let developers know why
certain places are vulnerable due to the concurrency bug (2) find the right inputs to trigger
concurrency attacks easily. Figure~\ref{fig:libsafe_result} shows a snippet of \xxx's
report on the \libsafe attack in Figure~\ref{fig:libsafe}.

% As we can see in Figure~\ref{fig:libsafe_result}, \xxx accurately pinpoints the
% affected dangerous operations as vulnerabilities. It also indicates how
% the vulnerability and the concurrency bug are connected. In this example, they
% are connected through control dependency. Even more, \xxx also shows what are the corrupted
% branch statements that this vulnerability is control dependent on. By utilizing all
% the above information, developers will be able to verify the vulnerability and
% adjust program inputs to reproduce it. 

\subsection{Reducing False Reports from Detectors}\label{sec:reduce}

% \subsection{Detecting Real-World Concurrency Attacks}\label{sec:real-attacks}
% To find out whether \xxx is able to find real world concurrency attacks, we
% evaluate our system in two different approaches. The first approach is applying
% \xxx on the latest version of applications to see if \xxx can detect any new
% concurrency bugs and the associated vulnerabilities. The second approach is applying
% \xxx on the existing buggy or vulnerable programs to see if \xxx can detect
% either any new or existed vulnerabilities.

Table~\ref{tab:racefilter} shows \xxx's race report reduction results. The 
second
column indicates the number of raw reports generated by our race detector.
The third column shows how many adhoc synchronizations we found.
The fourth column shows how many reports
our dynamic race verifier had removed. The fifth column shows the number of the 
remaining reports.

Overall, \xxx is able to prune 94\% cases of false positives in Linux kernel 
and 97.7\%
for the other applications. This significant reduction will help developers save
much diagnostic time. The performance of \xxx's static analysis tool is critical
because \xxx aims to be scalable to large programs. The last column of
Table~\ref{tab:racefilter} shows the average time 
cost of \xxx's static analysis tool per bug report. Overall, except for Linux 
kernel and \chrome, \xxx's analysis finished analyzing each program's bug 
reports within a few hours.

\begin{table}[h]
\footnotesize
\centering
\begin{tabular}{l|l|l|l|l|l}
\hline
{\bf Name} & {\bf R.R.} & {\bf A.S.} & {\bf *R.V.E.} & {\bf R.} &  {\bf A.C.} \\ \hline
\apache                &  715  & 7   & 1506  & 10   & 1.5m \\ %1516 - 10
\chrome                &  1715 & 1   & 1587  & 126  & 190m \\ %
\libsafe               &  3    & 0   & 0     & 3    & 3s\\
%\libvirt               &  0     & 0     & 0   & 0   & 0  \\
\linux                 & 24641 & 8   & N/A   & 1718 & 42.5m \\
\memcached             &  5376 & 0   & 5372  & 4    & 1.2m \\ %5376 - 4
%% \mongoose              &  90   & 57  & 57  & 0   &  0 & 0  \\
\mysql                 &  1123 & 6   & 783   & 18   & 5.1m\\   %870 - 87
\ssdb                  &  12   & 0   & 10    & 2    & 1.3m \\ \hline
Total                  & 31870 & 22  & 9258   & 1881 & N/A \\
\hline
\end{tabular}
\vspace{-.1in}
\caption{{\em \xxx's reduction on race detector reports.} \rm R.R. 
represents Race Reports, A.S. is the static Adhoc Synchronizations annotated by 
\xxx. R.V.E. is Race Verifier Elimination. * 
This result is the elimination on the race reports after annotation. The number 
could be bigger than the original race report number. R. is the Remaining result
after Race Verifier. A.C. is Average analysis time Cost.}
\label{tab:racefilter}
\vspace{-.2in}
\end{table}

\subsection{Detecting Known Attacks}\label{sec:known-attacks}

We applied \xxx on \nknownVul concurrency attacks listed in 
Table~\ref{tab:known_attacks}. \xxx detected all the vulnerabilities.
Currently \xxx incorporates two race detectors. There are other
types of concurrency bugs that can also lead to concurrency attacks, including
atomicity violations~\cite{lu:concurrency-bugs}. Atomicity violations 
can be detected by other detectors (\eg, CTrigger~\cite{ctrigger:asplos09}). By 
integrating these detectors (future work), \xxx's analysis and verifier 
components can detect more concurrency attacks.

%\begin{figure}
  %\centering
  %\lstset{basicstyle=\ttfamily\fontsize{6}{6}\selectfont,
  %morekeywords={_bytes,_sumbytes}}
  %\mbox{\lstinputlisting[mathescape,boxpos=t]{code/apache_25520_input.txt}}
  %\caption{{\em \apache-25520 buffer overflow triggering input.}
  %}
  %\label{fig:apache-25520-input}
%\end{figure}


% We wanted to extend our technique to Linux kernel, a more challenging program
% with a new runtime environment. Based on the reports generated by \ski,

Because all \xxx's dynamic verifiers of are implemented based on \lldb, which 
only supports applications, we haven't run these verifiers in Linux kernel. 
Nevertheless, \xxx's static vulnerability analyzer was applied to the Linux 
kernel and detected the evaluated concurrency attacks. For Linux kernel, our 
dynamic verifiers can be implemented in QEMU~\cite{qemu}. We leave the 
implementation in future work.
% \xxx's static 
% vulnerability analyzer is able to 
%  We believe the idea behind our dynamic components still hold on Linux 
% kernel and we've demonstrated the idea using user land applications. 
 
Aside from the discussed known and unknown concurrency attacks, \xxx generates 
180 reports in total. Due to the lack of domain knowledge and semantic 
understanding of program code, we didn't verify all of these 
potential vulnerability reports yet. These reports could either be benign 
races or new concurrency attacks. Nevertheless, by 
greatly reducing the number of reports from 31K to 
180 (Table~\ref{tab:racefilter} and Table~\ref{tab:eval}),
\xxx has greatly mitigated developers' burdens.

%\begin{table}[h]
%\footnotesize
%\centering
%\vspace{-.05in}
%\begin{tabular}{lrrrrr}
%{\bf Name} & {\bf Vul. Type} & {\bf Known} & {\bf Detected} \\
%\hline\\[-1.3ex]
%% \multirow{2}{*}{\apache-2.0.48} & Double Free & Y & \cmark \\
%% & Buffer Overflow & N & \cmark \\
%\apache-2.0.48 & Double Free & Y & \cmark \\
%% \hline
%% \apache-2.2.10     & Integer Overflow & N & \cmark \\
%\hline
%\chrome-6.0.472.58 & Use after free & Y & \cmark \\
%\hline
%\libsafe-2.0-16    & Buffer Overflow  & Y & \cmark \\
%\hline
%%\libvirt-1.2.0     & Null Ptr Deref  & Y & \xmark \\
%%\hline
%\linux-2.6.10      & Null Func Ptr Deref & Y & \cmark \\
%\hline
%\linux-2.6.29      & Privilege Escalation & Y & \cmark \\
%\hline
%\mysql-5.0.27      & Access Permission & Y & \cmark \\
%\hline
%\mysql-5.1.35      & Double Free & Y & \cmark \\
%%\ssdb                   &  12   &  0  & 0   &  0 & 3  \\
%%\chrome           &   X  & X   &  X & X  \\
%\hline\\[-2.3ex]                                          
%\end{tabular}
%\vspace{-.05in}
%\caption{{\em \xxx's concurrency detection results on known bugs.} \rm {All 
%these \nbackendDetected attacks were triggered by known bugs. 
%\nunknownVulknownBug out of these \nbackendDetected concurrency attacks were 
%previously unknown.}} 
%\label{tab:known_attacks}
%\vspace{-.1in}
%\end{table}

\begin{table}[h]
\footnotesize
\centering
\vspace{-.05in}
\begin{tabular}{lrrrrr}
{\bf Name} & {\bf Vul. Type} & {\bf Subtle Inputs} \\
\hline\\[-1.3ex]
% \multirow{2}{*}{\apache-2.0.48} & Double Free & Y & \cmark \\
% & Buffer Overflow & N & \cmark \\
\apache-2.0.48 & Double Free & PhP queries\\
% \hline
% \apache-2.2.10     & Integer Overflow & N & \cmark \\
\hline
\chrome-6.0.472.58 & Use after free & Js console.profile \\
\hline
\libsafe-2.0-16    & Buffer Overflow  & Loops with \v{strcpy()} \\
\hline
%\libvirt-1.2.0     & Null Ptr Deref  & Y & \xmark \\
%\hline
\linux-2.6.10      & Null Func Ptr Deref & Syscall parameters \\
\hline
\linux-2.6.29      & Privilege Escalation & Syscall parameters  \\
\hline
\mysql-5.0.27      & Access Permission & FLUSH PRIVILEGES \\
\hline
\mysql-5.1.35      & Double Free & SET PASSWORD \\
%\ssdb                   &  12   &  0  & 0   &  0 & 3  \\
%\chrome           &   X  & X   &  X & X  \\
\hline\\[-2.3ex]                                          
\end{tabular}
\vspace{-.05in}
\caption{{\em \xxx's detection results on known concurrency attacks.} \rm 
{With the listed subtle inputs, all these attacks were often 
triggered within 20 repeated queries or loops except the \apache one.}} 
\label{tab:known_attacks}
\vspace{-.1in}
\end{table}

%\subsection{Race Report Filter Result}\label{sec:racefilter}
%Table~\ref{tab:racefilter} shows \xxx's race report filtering results. Overall,
%\xxx is able to prune 94\% cases of false positives in Linux kernel and 62\%
%for the other applications. This significant pruning will help developers save
%much diagnose time. The performance of \xxx's static analysis tool is critical
%because \xxx aims to be scalable to large programs.
%The last column of Table~\ref{tab:racefilter} shows the average time 
%cost of \xxx's static analysis tool per bug report. Overall, except for Linux 
%kernel and \chrome, \xxx's analysis tool finished analyzing each application
%program's bug reports within a few hours in total.

%Based on our evaluation, we find out that our duplicate call stack filter prunes 
%out majority of the race reports. The reason is that many reported races are same
%except for the calling threads. Thus, we only need to analyze these kinds of reports
%only once. Our busy loop filter also filters our a reasonable number of false
%positives due to adhoc synchronizations. For our ``Busy Loop'' filter, we manually
%inspect all the cases and find out only 6 cases of them are false positives.


% \subsection{False Positives Study}\label{sec:false-positive}
% Besides the false positives introduced by the race detection module, 
% \xxx's static analysis module does introduce false positives in the following ways.
% 
% First, \xxx is not able to analysis dynamically linked libraries. As a result,
% \xxx will label the return value of these functions corrupted if any of is passed in parameters is corrupted.
% Second, when labeling dangerous operations prior to the flow analysis, \xxx
% uses simple alias analysis for those dangerous function calls uses indirect call.
% Third, \xxx's algorithm is path insensitive and flow insensitive, this will cause
% some over tainted cases during the flow analysis.
% 
% 
% \subsection{False Negative Study}\label{sec:false-negative}
% \xxx's static analysis part also introduces the following false negatives.
% First, during our flow analysis, in order to make it scalable, we skip those
% call sites with indirect calls e.g., function pointers.
% Second, we rely on the existing ``read'' call stack from the race reports to
% start the analysis. Other call stacks may also be able to read the corrupted variable.
% Third, \xxx is not able to handle inter-procedural indirect data and control
% dependency. As a result, cases that match this pattern will be missed.

%\begin{table}[t]
%\footnotesize
%\centering
%%\vspace{-.05in}
%\begin{tabular}{p{1.5cm}p{1cm}}
%{\bf Name} & {\bf Time Average} \\ 
%\hline\\[-1.3ex]
%\apache                     &  1.5m  \\
%\chrome                     &  184.2m \\
%\libsafe                    &  3s    \\ 
%\libvirt                    &  42s   \\
%\linux                      &  42.5m \\
%% \memcached                  &  1.2m  \\
%% \mongoose                   &  3s    \\
%\mysql                      &  5.1m  \\
%\ssdb                       &  1.3m  \\
%%\freebsd                    &  X    &  X  & X   &  X & X  \\
%\hline\\[-2.3ex]                                          
%\end{tabular}
%\vspace{-.05in}
%\caption{{\em Average time cost of \xxx's consequence analysis tool per bug 
%report.}} 
%\label{tab:performance}
%\vspace{-.2in}
%\end{table}

%\subsection{Performance of \xxx's Analysis Tool}\label{sec:perf}
%The performance of \xxx's static analysis tool is critical because \xxx aims to be 
%scalable to large programs. The last column of Table~\ref{tab:racefilter} shows the average time 
%cost of \xxx's static analysis tool per bug report. Overall, except for Linux 
%kernel and \chrome, \xxx's analysis tool finished analyzing each application program's bug 
%reports within a few hours in total.

\subsection{Detecting Previously Unknown Attacks}
\label{sec:unknown-attacks}

\xxx detected \nunknownVul previously unknown concurrency attacks caused by 
one new data race and two known data races. Analyzing whether known data races 
can lead to unknown concurrency attacks is still crucial (\S\ref{sec:findings}), 
because once attackers break in, they may remain latent for a long time.

% In this section, we are going to elaborate through these 
% new concurrency attacks in detail. We
% will also discuss why previous tools failed to detect these attacks.

\begin{figure}[h]
\centering
% \vspace{-.1in}
\includegraphics[width=0.9\columnwidth]{figures/ssdb}
\vspace{-.25in}
\caption{{\em A new concurrency bug and attack in \ssdb-1.9.2.}} 
\label{fig:ssdb}
\vspace{-.2in}
\end{figure}

\xxx detected a new data race and a previously unknown use-after-free 
concurrency attack in \ssdb. Figure~\ref{fig:ssdb} shows the details of 
this vulnerability. During server shutdown, \ssdb uses adhoc synchronization to 
synchronize between threads. However, it's possible that line 359 is executed 
before line 200. This race causes \v{log\_clean\_thread\_fun} to fail to break 
out of the while loop. Moreover, \v{log\_clean\_thread\_fun} could execute 
\v{del\_range} which could use \v{db} and cause a use after free. Even 
more, line 347 is a function pointer dereference which could cause log 
corruption or program crash if the memory area was reused by other threads.

\xxx's static analyzer (\S\ref{sec:algo}) identified the vulnerability site at 
line 347 because it is a pointer dereference. This site is 
control dependent on the corrupted branch on line 359. \xxx's dynamic 
vulnerability verifier (\S\ref{sec:vulnerability_verifier}) further verified 
that the other thread will free the memory area and set the pointer to NULL 
before the dereference within current thread. We reported this race and attack 
to \ssdb developers.

\begin{figure}[h]
\centering
\vspace{-.15in}
\includegraphics[width=0.9\columnwidth]{figures/apache-25520}
\vspace{-.15in}
\caption{{\em A new HTML integrity violation in \apache-2.0.48.}} 
\label{fig:apache-25520}
\vspace{-.1in}
\end{figure}

The second previously unknown concurrency attack stems from a known 
data race in \apache. This attack made \apache's own request logs be written 
into other users' HTML files stored in \apache, causing a HTML integrity 
violation and information leak. Figure~\ref{fig:apache-25520} shows the code of 
this vulnerability from the Apache-25520 bug~\cite{apache-bug-25520}.
\v{buf->outcnt} is shared among threads and serves as an index of a buffer
array. Due to a lack of proper synchronization when modifying this variable on
line 1362, a data race occurred and caused the server to write wrong 
contents to \v{buf->outbuf}. 

Worse, the wrong contents could also overflow \v{buf->outbuf} and cause a
buffer overflow. Even worse, \apache stores the file descriptor of its 
HTTP request log next to \v{buf->outbuf}. We constructed a one-byte 
overflow of \v{buf->outbuf}, corrupted this file descriptor, and made 
\apache's own HTTP request logs be written to an HTML file with the 
exact corrupted value of this file descriptor.

Although this data race has been well studied 
by researchers~\cite{lu:concurrency-bugs}, people thought the worst 
consequence of this bug would just be corrupting \apache's own request log. 
We were the first to detect this HTML integrity violation attack with \xxx 
and the first to construct the actual exploit scripts. 
% Leveraging this corruption, we made \apache write its HTTP request 
% logs to a particular html file stored in this server, which causes a severe
% integrity violation attack.

\xxx's vulnerability analysis (\S\ref{sec:algo}) pinpointed the vulnerable site 
at line 1359 and inferred that this line is data dependent on the corrupted 
variable on line 1358. \xxx's dynamic race verifier (\S\ref{sec:verify-race}) 
triggered the race and showed how many bytes in
\v{buf->outbuf} were overflowed.

\begin{figure}[h]
\centering
\vspace{-.15in}
\includegraphics[width=0.85\columnwidth]{figures/apache-46215}
\vspace{-.4in}
\caption{{\em A new integer overflow and DoS attack based on \apache-46215.}} 
\label{fig:apache-46215}
\vspace{-.1in}
\end{figure}

% Moreover, we've detected an integer overflow vulnerability that could cause a 
% worker thread to be absolutely
% ignored by load balancer for incoming requests based on a previously reported 
% bug. 
% This attack causes degraded server performance or DOS attack in the worst 
% case. 
The third previously unknown concurrency attack was an integer overflow DoS 
attack based on a known \apache-46215 data race. Figure~\ref{fig:apache-46215} 
shows the \apache-46215 bug~\cite{apache-bug-46215}. Each \apache worker thread 
contains a field \v{worker->s->busy} to indicate its busyness. An \apache 
load balancer component contains threads to concurrently increment or decrement 
these flags for worker threads when they start or finish serving requests. 
However, as shown in line 616, this is a data race because developers forgot to 
use a lock during the counter increment and decrement.

Over years, this busyness counter has been viewed a statistic and its 
data race does not matter much. Unfortunately, this counter is an unsigned 
integer, and an integer overflow could be triggered during the decrement and 
could make the counter the largest unsigned integer (\ie, marking a thread the 
``busiest" one). The check in line 617 can be easily bypassed because of the 
race. Because load balancer assigns future requests based on the worker 
threads' counters, arbitrary worker threads in \apache can be viewed the 
busiest ones and be completely ignored, causing a DoS attack on these threads 
and a significant downgrade of \apache's throughput.

\xxx detected this concurrency attack as follows. \xxx's race detector detected 
a race between line 617 and line 1192. \xxx's dynamic race verifier reported 
a detailed dynamic race information including the racing instructions, the 
value they could read or write to the variable and the type of the variable. 
We then found \v{worker->s->busy} in some worker threads had an overflowed 
value: \v{18,446,744,073,709,551,614}. \xxx's vulnerability analysis 
(\S\ref{sec:algo}) reported that a pointer assignment could be control dependent 
on the corrupted branch of line 1192. \xxx's vulnerability verifier verified 
that the branch was indeed corrupted and line 1195 was reachable.
% We also
% found out what requests the workers were executing at that time by manually 
% inspecting program states and used those type of requests as vulnerable 
% inputs. 

These three previously unknown concurrency attacks were overlooked by 
prior reliability and security tools mainly due to three reasons. First, 
compared to \xxx's reduced vulnerable reports, the data races of these three 
attacks were buried within at least 87X more false reports in \apache and 6X 
more in \ssdb produced by the prior \tsan race detector. Second, without 
\xxx's static bug-to-attack propagation analysis (\S\ref{sec:algo}), even though 
the races can be detected by existing race detectors, the security 
consequences of these bugs were unknown to detectors. Third, without 
\xxx's dynamic race verifier (\S\ref{sec:verify-race}) and 
vulnerability verifier (\S\ref{sec:vulnerability_verifier}), whether these 
races and their attacks can be realized were unknown either.

% Developers could seek the 
% help
% from impact analyzers like taint analysis to ease the task.
% However, static impact analysis could generate tons of potential vulnerable
% operations and hard or impossible to verify. While
% dynamic impact analysis misses the vulnerable operation due to execution path
% divergence during dynamic run. 
