\section{Implimentation Details} \label{sec:impl}

Concurrency error reports are often plagued with ample false positive reports,
where the structural thread interleavings are indeed buggy, but these ``bugs"
are often benign or intended behaviors (\eg, customized, ad-hoc
synchronizations~\cite{syncfinder:osdi10}). Pruning these reports can
greatly reduce both the developers' and the \xxx vulnerability analyzer's
burdens on analyzing the bug reports.

\xxx provides a hybrid filter that combines both static and dynamic program
analysis techniques to efficiently remove false positives. Race reports generated
by race detectors are first filtered by our static filter and then filtered by
our dynamic filter. These
filters are general to both applications and kernels; they can also be applied
to existing concurrency error detection tools, confirmed in our evaluation 
(\S\ref{sec:evaluation}).

% Duplicate call stack filter.
Our static filter handles three types of false positives.
The first type is duplicate call stack filter. Lots of bug reports share the 
same \v{load} instruction and the same call stack for this instruction. We
simply prune all these reports but one. This filter is particularly effective 
on pruning duplicate reports for the Linux kernel (\S\ref{sec:racefilter}), 
thanking to our \xxx framework that enables call stacks for kernels 
(\S\ref{sec:integration}).



% (TBD: can we give an example in our bug study that we can find but SyncFinder
% can not find? For example, read and write are in different functions?)

% Bit operation filter.
% For tsan hacking:

%The third type is bit operations, in which different threads access distinct
%bits of a shared variable. We address this type by providing a statistics of all
%the bits modified for each write instruction. Whenever a write instruction is
%encountered, the thread-sanitizer will then XOR the original value and the new
%value to compute a bitmap of all the bits changed at this particular write. All
%such bitmap for a specific write instruction will be or'ed to deduce the
%aforementioned statistics. The statistics will then be fed to back-end to check
%if the read side is using any of the bits. If so, we declare the pair as a real
%race and continue analysis on the back-end. Otherwise, we tag such a report as a
%``bit operation".
% If given a read/write pair of the same variable,
% where the write thread is modifying the bit field not used by the read thread,
% it will be misidentified as a race.

% based on the number of bits that hasn't been changed by the write,
% nor used by the read.

% For example, the race will be given the lowest priority if
% union of the bits used by read and the bits changed by write equals the total
% bits of the variable and the intersection of the two is empty. Out tool will
% still analysis the low priority races while advising the developer to not
% focusing primarily on them.

% Mutex operation filter.
The third type is customized mutex operations. Developers implement their own
synchronization primitives for performance consideration. We address this type by
filtering
out the reports if the latest called function in a bug report's call stack
contains key words ``mutex, rw\_lock, rwlock, mtx, spinlock, spin\_lock",
thanking to our \xxx framework that enables call stacks for both applications
and kernels.

% A general design for both applications and kernels.

% How to work with applications and application detection tools.




